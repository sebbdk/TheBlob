package  {	import Box2DAS.*;	import Box2DAS.Collision.*;	import Box2DAS.Collision.Shapes.*;	import Box2DAS.Common.*;	import Box2DAS.Dynamics.*;	import Box2DAS.Dynamics.Contacts.*;	import Box2DAS.Dynamics.Joints.*;	import misc.*;		public class TheoJansen extends Test	{		public function TheoJansen() 		{			super();			// Set Text field			Main.txt.text = "Theo Jansen Walker. Controls: A, S, D, M.";			// scale walker by variable to easily change size			tScale = scale * 2;			// Set position in world space			m_offset = new V2(120.0/scale, 250/scale);			m_motorSpeed = -2.0;			m_motorOn = true;			var pivot:V2 = new V2(0.0, -24.0/tScale);			var body:b2Body;			b2Def.body.type = b2Body.b2_dynamicBody;						for (var i:int = 0; i < 40; ++i)			{				b2Def.circle.m_radius = 7.5 / tScale;				// Position in world space				b2Def.body.position.v2 = new V2((Math.random() * 620 + 10) / scale, 350 / scale);				body = CreateBody(b2Def.body);				body.CreateFixtureShape(b2Def.circle, 1.0);			}			{				b2Def.polygon.SetAsBox(75 / tScale, 30 / tScale);				b2Def.fixture.shape = b2Def.polygon;				b2Def.fixture.density = 1.0;				b2Def.fixture.filter.groupIndex = -1;				b2Def.body.position.v2 = V2.add(pivot, m_offset);				m_chassis = CreateBody(b2Def.body);				m_chassis.CreateFixture(b2Def.fixture);			}			{				b2Def.circle.m_radius = 48 / tScale;				b2Def.fixture.shape = b2Def.circle;				b2Def.fixture.density = 1.0;				b2Def.fixture.filter.groupIndex = -1;				b2Def.body.position.v2 = V2.add(pivot, m_offset);				m_wheel = CreateBody(b2Def.body);				m_wheel.CreateFixture(b2Def.fixture);			}			{				var po:V2 = V2.add(pivot, m_offset);				b2Def.revoluteJoint.Initialize(m_wheel, m_chassis, po);				b2Def.revoluteJoint.collideConnected = false;				b2Def.revoluteJoint.motorSpeed = m_motorSpeed;				b2Def.revoluteJoint.maxMotorTorque = 400.0;				b2Def.revoluteJoint.enableMotor = m_motorOn;				m_motorJoint = CreateJoint(b2Def.revoluteJoint) as b2RevoluteJoint;				b2Def.revoluteJoint.enableMotor = false;			}			var wheelAnchor:V2 = V2.add(pivot, new V2(0, -0.8));			wheelAnchor = new V2(0.0, 24.0/tScale);			wheelAnchor.add(pivot);			CreateLeg(-1.0, wheelAnchor);			CreateLeg(1.0, wheelAnchor);			m_wheel.SetTransform(m_wheel.GetPosition(), 120.0 * Math.PI / 180.0);			CreateLeg(-1.0, wheelAnchor);			CreateLeg(1.0, wheelAnchor);			m_wheel.SetTransform(m_wheel.GetPosition(), -120.0 * Math.PI / 180.0);			CreateLeg(-1.0, wheelAnchor);			CreateLeg(1.0, wheelAnchor);						b2Def.fixture.filter.groupIndex = 0;		}		private function CreateLeg(s:Number, wheelAnchor:V2):void{						var p1:V2 = new V2(162 * s/tScale, 183/tScale);			var p2:V2 = new V2(216 * s/tScale, 36 /tScale);			var p3:V2 = new V2(129 * s/tScale, 57 /tScale);			var p4:V2 = new V2( 93 * s/tScale, -24  /tScale);			var p5:V2 = new V2(180 * s/tScale, -45  /tScale);			var p6:V2 = new V2( 75 * s/tScale, -111 /tScale);						var sd1:b2PolygonShape = new b2PolygonShape();			var sd2:b2PolygonShape = new b2PolygonShape();			var fd1:b2FixtureDef = new b2FixtureDef();			var fd2:b2FixtureDef = new b2FixtureDef();			fd1.shape = sd1;			fd2.shape = sd2;			fd1.filter.groupIndex = -1;			fd1.friction = 0.8;			fd2.filter.groupIndex = -1;			fd1.density = 1.0;			fd2.density = 1.0;						if (s > 0.0)			{				sd1.Set(Vector.<V2>([p3, p2, p1]));				sd2.Set(Vector.<V2>([					V2.subtract(p6, p4),					V2.subtract(p5, p4),					new V2()					]));			}			else			{				sd1.Set(Vector.<V2>([p2, p3, p1]));				sd2.Set(Vector.<V2>([					V2.subtract(p5, p4),					V2.subtract(p6, p4),					new V2()					]));			}						var bd1:b2BodyDef = new b2BodyDef();			var bd2:b2BodyDef = new b2BodyDef();			bd1.type = b2Body.b2_dynamicBody;			bd2.type = b2Body.b2_dynamicBody;			bd1.position.v2 = m_offset;			bd2.position.v2 = V2.add(p4, m_offset);						bd1.angularDamping = 10.0;			bd2.angularDamping = 10.0;						var body1:b2Body = CreateBody(bd1);			var body2:b2Body = CreateBody(bd2);						body1.CreateFixture(fd1);			body2.CreateFixture(fd2);						sd1.destroy();			sd2.destroy();			fd1.destroy();			fd2.destroy();			bd1.destroy();			bd2.destroy();									 //Using a soft distance constraint can reduce some jitter.			 //It also makes the structure seem a bit more fluid by			 //acting like a suspension system.			b2Def.distanceJoint.dampingRatio = 0.5;			b2Def.distanceJoint.frequencyHz = 10.0;						b2Def.distanceJoint.Initialize(body1, body2, V2.add(p2, m_offset), V2.add(p5, m_offset));			CreateJoint(b2Def.distanceJoint);						b2Def.distanceJoint.Initialize(body1, body2, V2.add(p3, m_offset), V2.add(p4, m_offset));			CreateJoint(b2Def.distanceJoint);						b2Def.distanceJoint.Initialize(body1, m_wheel, V2.add(p3, m_offset), V2.add(wheelAnchor, m_offset));			CreateJoint(b2Def.distanceJoint);						b2Def.distanceJoint.Initialize(body2, m_wheel, V2.add(p6, m_offset), V2.add(wheelAnchor, m_offset));			CreateJoint(b2Def.distanceJoint);						b2Def.revoluteJoint.Initialize(body2, m_chassis, V2.add(p4, m_offset));			CreateJoint(b2Def.revoluteJoint);		}								public override function EnterFrame():void{						if (Input.kp('A')){ // A				m_chassis.SetAwake(true)				m_motorJoint.SetMotorSpeed(-m_motorSpeed);			}			if (Input.kp('S')){ // S				m_chassis.SetAwake(true);				m_motorJoint.SetMotorSpeed(0.0);			}			if (Input.kp('D')){ // D				m_chassis.SetAwake(true);				m_motorJoint.SetMotorSpeed(m_motorSpeed);			}			if (Input.kp('M')){ // M				m_chassis.SetAwake(true);				m_motorJoint.EnableMotor(!m_motorJoint.IsMotorEnabled());			}						super.EnterFrame();		}						//======================		// Member Data 		//======================		private var tScale:Number;				private var m_offset:V2 = new V2();		private var m_chassis:b2Body;		private var m_wheel:b2Body;		private var m_motorJoint:b2RevoluteJoint;		private var m_motorOn:Boolean = true;		private var m_motorSpeed:Number;			}}