----------b2Vec2public function get x():Number { return mem._mrf(_ptr + 0); }public function set x(v:Number):void { mem._mwf(_ptr + 0, v); }public function get y():Number { return mem._mrf(_ptr + 4); }public function set y(v:Number):void { mem._mwf(_ptr + 4, v); }----------b2Vec3public function get x():Number { return mem._mrf(_ptr + 0); }public function set x(v:Number):void { mem._mwf(_ptr + 0, v); }public function get y():Number { return mem._mrf(_ptr + 4); }public function set y(v:Number):void { mem._mwf(_ptr + 4, v); }public function get z():Number { return mem._mrf(_ptr + 8); }public function set z(v:Number):void { mem._mwf(_ptr + 8, v); }----------b2Mat22public var col1:b2Vec2; // col1 = new b2Vec2(_ptr + 0);public var col2:b2Vec2; // col2 = new b2Vec2(_ptr + 8);----------b2Mat33public var col1:b2Vec3; // col1 = new b2Vec3(_ptr + 0);public var col2:b2Vec3; // col2 = new b2Vec3(_ptr + 12);public var col3:b2Vec3; // col3 = new b2Vec3(_ptr + 24);----------b2Transformpublic var position:b2Vec2; // position = new b2Vec2(_ptr + 0);public var R:b2Mat22; // R = new b2Mat22(_ptr + 8);----------b2Sweeppublic var localCenter:b2Vec2; // localCenter = new b2Vec2(_ptr + 0);public var c0:b2Vec2; // c0 = new b2Vec2(_ptr + 8);public var c:b2Vec2; // c = new b2Vec2(_ptr + 16);public function get a0():Number { return mem._mrf(_ptr + 24); }public function set a0(v:Number):void { mem._mwf(_ptr + 24, v); }public function get a():Number { return mem._mrf(_ptr + 28); }public function set a(v:Number):void { mem._mwf(_ptr + 28, v); }public function get alpha0():Number { return mem._mrf(_ptr + 32); }public function set alpha0(v:Number):void { mem._mwf(_ptr + 32, v); }----------b2MassDatapublic function get mass():Number { return mem._mrf(_ptr + 0); }public function set mass(v:Number):void { mem._mwf(_ptr + 0, v); }public var center:b2Vec2; // center = new b2Vec2(_ptr + 4);public function get I():Number { return mem._mrf(_ptr + 12); }public function set I(v:Number):void { mem._mwf(_ptr + 12, v); }----------b2Filterpublic function get categoryBits():int { return mem._mru16(_ptr + 0); }public function set categoryBits(v:int):void { mem._mw16(_ptr + 0, v); }public function get maskBits():int { return mem._mru16(_ptr + 2); }public function set maskBits(v:int):void { mem._mw16(_ptr + 2, v); }public function get groupIndex():int { return mem._mrs16(_ptr + 4); }public function set groupIndex(v:int):void { mem._mw16(_ptr + 4, v); }----------b2AABBpublic var lowerBound:b2Vec2; // lowerBound = new b2Vec2(_ptr + 0);public var upperBound:b2Vec2; // upperBound = new b2Vec2(_ptr + 8);----------b2Worldpublic function get m_flags():int { return mem._mr32(_ptr + 102868); }public function set m_flags(v:int):void { mem._mw32(_ptr + 102868, v); }public function get m_bodyCount():int { return mem._mr32(_ptr + 102960); }public function set m_bodyCount(v:int):void { mem._mw32(_ptr + 102960, v); }public function get m_jointCount():int { return mem._mr32(_ptr + 102964); }public function set m_jointCount(v:int):void { mem._mw32(_ptr + 102964, v); }public var m_gravity:b2Vec2; // m_gravity = new b2Vec2(_ptr + 102968);public function get m_allowSleep():Boolean { return mem._mru8(_ptr + 102976) == 1; }public function set m_allowSleep(v:Boolean):void { mem._mw8(_ptr + 102976, v ? 1 : 0); }public var m_contactManager:b2ContactManager; // m_contactManager = new b2ContactManager(_ptr + 102872);public function get m_warmStarting():Boolean { return mem._mru8(_ptr + 102992) == 1; }public function set m_warmStarting(v:Boolean):void { mem._mw8(_ptr + 102992, v ? 1 : 0); }public function get m_continuousPhysics():Boolean { return mem._mru8(_ptr + 102993) == 1; }public function set m_continuousPhysics(v:Boolean):void { mem._mw8(_ptr + 102993, v ? 1 : 0); }----------b2ContactIDpublic function get key():int { return mem._mr32(_ptr + 0); }public function set key(v:int):void { mem._mw32(_ptr + 0, v); }public function get cf.indexA():int { return mem._mru8(_ptr + 0); }public function set cf.indexA(v:int):void { mem._mw8(_ptr + 0, v); }public function get cf.indexB():int { return mem._mru8(_ptr + 1); }public function set cf.indexB(v:int):void { mem._mw8(_ptr + 1, v); }public function get cf.typeA():int { return mem._mru8(_ptr + 2); }public function set cf.typeA(v:int):void { mem._mw8(_ptr + 2, v); }public function get cf.typeB():int { return mem._mru8(_ptr + 3); }public function set cf.typeB(v:int):void { mem._mw8(_ptr + 3, v); }----------b2ManifoldPointpublic var localPoint:b2Vec2; // localPoint = new b2Vec2(_ptr + 0);public function get normalImpulse():Number { return mem._mrf(_ptr + 8); }public function set normalImpulse(v:Number):void { mem._mwf(_ptr + 8, v); }public function get tangentImpulse():Number { return mem._mrf(_ptr + 12); }public function set tangentImpulse(v:Number):void { mem._mwf(_ptr + 12, v); }public var id:b2ContactID; // id = new b2ContactID(_ptr + 16);public function get isNew():Boolean { return mem._mru8(_ptr + 20) == 1; }public function set isNew(v:Boolean):void { mem._mw8(_ptr + 20, v ? 1 : 0); }----------b2Manifoldpublic var localNormal:b2Vec2; // localNormal = new b2Vec2(_ptr + 48);public var localPoint:b2Vec2; // localPoint = new b2Vec2(_ptr + 56);public function get type():int { return mem._mrs8(_ptr + 64); }public function set type(v:int):void { mem._mw8(_ptr + 64, v); }public function get pointCount():int { return mem._mr32(_ptr + 68); }public function set pointCount(v:int):void { mem._mw32(_ptr + 68, v); }public var points[0]:b2ManifoldPoint; // points[0] = new b2ManifoldPoint(_ptr + 0);public var points[1]:b2ManifoldPoint; // points[1] = new b2ManifoldPoint(_ptr + 24);----------b2WorldManifoldpublic var normal:b2Vec2; // normal = new b2Vec2(_ptr + 0);public var points[0]:b2Vec2; // points[0] = new b2Vec2(_ptr + 8);public var points[1]:b2Vec2; // points[1] = new b2Vec2(_ptr + 16);----------b2Contactpublic function get m_flags():int { return mem._mr32(_ptr + 4); }public function set m_flags(v:int):void { mem._mw32(_ptr + 4, v); }public var _m_fixtureA:b2Fixture;public function get m_fixtureA():b2Fixture { return _m_fixtureA; }public function set m_fixtureA(v:b2Fixture):void { mem._mw32(_ptr + 48, v._ptr); _m_fixtureA = v; }public var _m_fixtureB:b2Fixture;public function get m_fixtureB():b2Fixture { return _m_fixtureB; }public function set m_fixtureB(v:b2Fixture):void { mem._mw32(_ptr + 52, v._ptr); _m_fixtureB = v; }public var m_manifold:b2Manifold; // m_manifold = new b2Manifold(_ptr + 64);public function get m_indexA():int { return mem._mr32(_ptr + 56); }public function set m_indexA(v:int):void { mem._mw32(_ptr + 56, v); }public function get m_indexB():int { return mem._mr32(_ptr + 60); }public function set m_indexB(v:int):void { mem._mw32(_ptr + 60, v); }public function get m_toiCount():int { return mem._mr32(_ptr + 136); }public function set m_toiCount(v:int):void { mem._mw32(_ptr + 136, v); }public function get m_toi():Number { return mem._mrf(_ptr + 140); }public function set m_toi(v:Number):void { mem._mwf(_ptr + 140, v); }public function get frictionDisabled():Boolean { return mem._mru8(_ptr + 144) == 1; }public function set frictionDisabled(v:Boolean):void { mem._mw8(_ptr + 144, v ? 1 : 0); }public function get m_next():int { return mem._mr32(_ptr + 12); }public function set m_next(v:int):void { mem._mw32(_ptr + 12, v); }public function get m_prev():int { return mem._mr32(_ptr + 8); }public function set m_prev(v:int):void { mem._mw32(_ptr + 8, v); }----------b2BodyDefpublic function get userData():int { return mem._mr32(_ptr + 44); }public function set userData(v:int):void { mem._mw32(_ptr + 44, v); }public var position:b2Vec2; // position = new b2Vec2(_ptr + 4);public function get angle():Number { return mem._mrf(_ptr + 12); }public function set angle(v:Number):void { mem._mwf(_ptr + 12, v); }public var linearVelocity:b2Vec2; // linearVelocity = new b2Vec2(_ptr + 16);public function get angularVelocity():Number { return mem._mrf(_ptr + 24); }public function set angularVelocity(v:Number):void { mem._mwf(_ptr + 24, v); }public function get linearDamping():Number { return mem._mrf(_ptr + 28); }public function set linearDamping(v:Number):void { mem._mwf(_ptr + 28, v); }public function get angularDamping():Number { return mem._mrf(_ptr + 32); }public function set angularDamping(v:Number):void { mem._mwf(_ptr + 32, v); }public function get allowSleep():Boolean { return mem._mru8(_ptr + 36) == 1; }public function set allowSleep(v:Boolean):void { mem._mw8(_ptr + 36, v ? 1 : 0); }public function get awake():Boolean { return mem._mru8(_ptr + 37) == 1; }public function set awake(v:Boolean):void { mem._mw8(_ptr + 37, v ? 1 : 0); }public function get fixedRotation():Boolean { return mem._mru8(_ptr + 38) == 1; }public function set fixedRotation(v:Boolean):void { mem._mw8(_ptr + 38, v ? 1 : 0); }public function get bullet():Boolean { return mem._mru8(_ptr + 39) == 1; }public function set bullet(v:Boolean):void { mem._mw8(_ptr + 39, v ? 1 : 0); }public function get type():int { return mem._mrs16(_ptr + 0); }public function set type(v:int):void { mem._mw16(_ptr + 0, v); }public function get active():Boolean { return mem._mru8(_ptr + 40) == 1; }public function set active(v:Boolean):void { mem._mw8(_ptr + 40, v ? 1 : 0); }public function get inertiaScale():Number { return mem._mrf(_ptr + 48); }public function set inertiaScale(v:Number):void { mem._mwf(_ptr + 48, v); }----------b2Bodypublic function get m_flags():int { return mem._mru16(_ptr + 4); }public function set m_flags(v:int):void { mem._mw16(_ptr + 4, v); }public function get m_type():int { return mem._mrs16(_ptr + 0); }public function set m_type(v:int):void { mem._mw16(_ptr + 0, v); }public function get m_islandIndex():int { return mem._mr32(_ptr + 8); }public function set m_islandIndex(v:int):void { mem._mw32(_ptr + 8, v); }public var m_xf:b2Transform; // m_xf = new b2Transform(_ptr + 12);public var m_sweep:b2Sweep; // m_sweep = new b2Sweep(_ptr + 36);public var m_linearVelocity:b2Vec2; // m_linearVelocity = new b2Vec2(_ptr + 72);public function get m_angularVelocity():Number { return mem._mrf(_ptr + 80); }public function set m_angularVelocity(v:Number):void { mem._mwf(_ptr + 80, v); }public var m_force:b2Vec2; // m_force = new b2Vec2(_ptr + 84);public function get m_torque():Number { return mem._mrf(_ptr + 92); }public function set m_torque(v:Number):void { mem._mwf(_ptr + 92, v); }public function get m_fixtureCount():int { return mem._mr32(_ptr + 112); }public function set m_fixtureCount(v:int):void { mem._mw32(_ptr + 112, v); }public function get m_mass():Number { return mem._mrf(_ptr + 124); }public function set m_mass(v:Number):void { mem._mwf(_ptr + 124, v); }public function get m_invMass():Number { return mem._mrf(_ptr + 128); }public function set m_invMass(v:Number):void { mem._mwf(_ptr + 128, v); }public function get m_I():Number { return mem._mrf(_ptr + 132); }public function set m_I(v:Number):void { mem._mwf(_ptr + 132, v); }public function get m_invI():Number { return mem._mrf(_ptr + 136); }public function set m_invI(v:Number):void { mem._mwf(_ptr + 136, v); }public function get m_linearDamping():Number { return mem._mrf(_ptr + 140); }public function set m_linearDamping(v:Number):void { mem._mwf(_ptr + 140, v); }public function get m_angularDamping():Number { return mem._mrf(_ptr + 144); }public function set m_angularDamping(v:Number):void { mem._mwf(_ptr + 144, v); }public function get m_sleepTime():Number { return mem._mrf(_ptr + 148); }public function set m_sleepTime(v:Number):void { mem._mwf(_ptr + 148, v); }public function get m_userData():int { return mem._mr32(_ptr + 152); }public function set m_userData(v:int):void { mem._mw32(_ptr + 152, v); }public var m_contactList:b2ContactEdge; // m_contactList = new b2ContactEdge(_ptr + 120);public var m_jointList:b2JointEdge; // m_jointList = new b2JointEdge(_ptr + 116);----------b2ContactEdgepublic var other:b2Body; // other = new b2Body(_ptr + 0);public var contact:b2Contact; // contact = new b2Contact(_ptr + 4);public var prev:b2ContactEdge; // prev = new b2ContactEdge(_ptr + 8);public var next:b2ContactEdge; // next = new b2ContactEdge(_ptr + 12);----------b2JointEdgepublic var other:b2Body; // other = new b2Body(_ptr + 0);public var joint:b2Joint; // joint = new b2Joint(_ptr + 4);public var prev:b2JointEdge; // prev = new b2JointEdge(_ptr + 8);public var next:b2JointEdge; // next = new b2JointEdge(_ptr + 12);----------b2Shapepublic function get m_type():int { return mem._mrs8(_ptr + 4); }public function set m_type(v:int):void { mem._mw8(_ptr + 4, v); }public function get m_radius():Number { return mem._mrf(_ptr + 8); }public function set m_radius(v:Number):void { mem._mwf(_ptr + 8, v); }public function get m_area():Number { return mem._mrf(_ptr + 12); }public function set m_area(v:Number):void { mem._mwf(_ptr + 12, v); }----------b2CircleShapepublic var m_p:b2Vec2; // m_p = new b2Vec2(_ptr + 16);----------b2PolygonShapepublic var m_centroid:b2Vec2; // m_centroid = new b2Vec2(_ptr + 16);public function get m_vertices():Vector.<V2> { return readVertices(_ptr + 24, m_vertexCount); }public function set m_vertices(v:Vector.<V2>):void { writeVertices(_ptr + 24, v); m_vertexCount = v.length; }public function get m_normals():Vector.<V2> { return readVertices(_ptr + 88, m_vertexCount); }public function set m_normals(v:Vector.<V2>):void { writeVertices(_ptr + 88, v); m_vertexCount = v.length; }public function get m_vertexCount():int { return mem._mr32(_ptr + 152); }public function set m_vertexCount(v:int):void { mem._mw32(_ptr + 152, v); }----------b2FixtureDefpublic var _shape:b2Shape;public function get shape():b2Shape { return _shape; }public function set shape(v:b2Shape):void { mem._mw32(_ptr + 4, v._ptr); _shape = v; }public function get userData():int { return mem._mr32(_ptr + 8); }public function set userData(v:int):void { mem._mw32(_ptr + 8, v); }public function get friction():Number { return mem._mrf(_ptr + 12); }public function set friction(v:Number):void { mem._mwf(_ptr + 12, v); }public function get restitution():Number { return mem._mrf(_ptr + 16); }public function set restitution(v:Number):void { mem._mwf(_ptr + 16, v); }public function get density():Number { return mem._mrf(_ptr + 20); }public function set density(v:Number):void { mem._mwf(_ptr + 20, v); }public function get isSensor():Boolean { return mem._mru8(_ptr + 24) == 1; }public function set isSensor(v:Boolean):void { mem._mw8(_ptr + 24, v ? 1 : 0); }public var filter:b2Filter; // filter = new b2Filter(_ptr + 26);----------b2Fixturepublic function get m_reportBeginContact():Boolean { return mem._mru8(_ptr + 0) == 1; }public function set m_reportBeginContact(v:Boolean):void { mem._mw8(_ptr + 0, v ? 1 : 0); }public function get m_reportEndContact():Boolean { return mem._mru8(_ptr + 1) == 1; }public function set m_reportEndContact(v:Boolean):void { mem._mw8(_ptr + 1, v ? 1 : 0); }public function get m_reportPreSolve():Boolean { return mem._mru8(_ptr + 2) == 1; }public function set m_reportPreSolve(v:Boolean):void { mem._mw8(_ptr + 2, v ? 1 : 0); }public function get m_reportPostSolve():Boolean { return mem._mru8(_ptr + 3) == 1; }public function set m_reportPostSolve(v:Boolean):void { mem._mw8(_ptr + 3, v ? 1 : 0); }public var _m_body:b2Body;public function get m_body():b2Body { return _m_body; }public function set m_body(v:b2Body):void { mem._mw32(_ptr + 12, v._ptr); _m_body = v; }public var _m_shape:b2Shape;public function get m_shape():b2Shape { return _m_shape; }public function set m_shape(v:b2Shape):void { mem._mw32(_ptr + 16, v._ptr); _m_shape = v; }public function get m_friction():Number { return mem._mrf(_ptr + 20); }public function set m_friction(v:Number):void { mem._mwf(_ptr + 20, v); }public function get m_restitution():Number { return mem._mrf(_ptr + 24); }public function set m_restitution(v:Number):void { mem._mwf(_ptr + 24, v); }public function get m_proxies():int { return mem._mr32(_ptr + 28); }public function set m_proxies(v:int):void { mem._mw32(_ptr + 28, v); }public var m_filter:b2Filter; // m_filter = new b2Filter(_ptr + 36);public function get m_isSensor():Boolean { return mem._mru8(_ptr + 42) == 1; }public function set m_isSensor(v:Boolean):void { mem._mw8(_ptr + 42, v ? 1 : 0); }public function get m_userData():int { return mem._mr32(_ptr + 44); }public function set m_userData(v:int):void { mem._mw32(_ptr + 44, v); }public function get m_density():Number { return mem._mrf(_ptr + 4); }public function set m_density(v:Number):void { mem._mwf(_ptr + 4, v); }public function get m_conveyorBeltSpeed():Number { return mem._mrf(_ptr + 48); }public function set m_conveyorBeltSpeed(v:Number):void { mem._mwf(_ptr + 48, v); }----------b2FixtureProxypublic var aabb:b2AABB; // aabb = new b2AABB(_ptr + 0);public function get proxyId():int { return mem._mr32(_ptr + 24); }public function set proxyId(v:int):void { mem._mw32(_ptr + 24, v); }----------b2JointDefpublic function get type():int { return mem._mrs16(_ptr + 0); }public function set type(v:int):void { mem._mw16(_ptr + 0, v); }public function get userData():int { return mem._mr32(_ptr + 4); }public function set userData(v:int):void { mem._mw32(_ptr + 4, v); }public var _bodyA:b2Body;public function get bodyA():b2Body { return _bodyA; }public function set bodyA(v:b2Body):void { mem._mw32(_ptr + 8, v._ptr); _bodyA = v; }public var _bodyB:b2Body;public function get bodyB():b2Body { return _bodyB; }public function set bodyB(v:b2Body):void { mem._mw32(_ptr + 12, v._ptr); _bodyB = v; }public function get collideConnected():Boolean { return mem._mru8(_ptr + 16) == 1; }public function set collideConnected(v:Boolean):void { mem._mw8(_ptr + 16, v ? 1 : 0); }----------b2Jointpublic function get m_type():int { return mem._mrs16(_ptr + 4); }public function set m_type(v:int):void { mem._mw16(_ptr + 4, v); }public var _m_bodyA:b2Body;public function get m_bodyA():b2Body { return _m_bodyA; }public function set m_bodyA(v:b2Body):void { mem._mw32(_ptr + 48, v._ptr); _m_bodyA = v; }public var _m_bodyB:b2Body;public function get m_bodyB():b2Body { return _m_bodyB; }public function set m_bodyB(v:b2Body):void { mem._mw32(_ptr + 52, v._ptr); _m_bodyB = v; }public function get m_islandFlag():Boolean { return mem._mru8(_ptr + 56) == 1; }public function set m_islandFlag(v:Boolean):void { mem._mw8(_ptr + 56, v ? 1 : 0); }public function get m_collideConnected():Boolean { return mem._mru8(_ptr + 57) == 1; }public function set m_collideConnected(v:Boolean):void { mem._mw8(_ptr + 57, v ? 1 : 0); }public function get m_userData():Number { return mem._mrf(_ptr + 60); }public function set m_userData(v:Number):void { mem._mwf(_ptr + 60, v); }----------b2DistanceJointDefpublic var localAnchorA:b2Vec2; // localAnchorA = new b2Vec2(_ptr + 20);public var localAnchorB:b2Vec2; // localAnchorB = new b2Vec2(_ptr + 28);public function get length():Number { return mem._mrf(_ptr + 36); }public function set length(v:Number):void { mem._mwf(_ptr + 36, v); }public function get frequencyHz():Number { return mem._mrf(_ptr + 40); }public function set frequencyHz(v:Number):void { mem._mwf(_ptr + 40, v); }public function get dampingRatio():Number { return mem._mrf(_ptr + 44); }public function set dampingRatio(v:Number):void { mem._mwf(_ptr + 44, v); }----------b2DistanceJointpublic var m_localAnchor1:b2Vec2; // m_localAnchor1 = new b2Vec2(_ptr + 96);public var m_localAnchor2:b2Vec2; // m_localAnchor2 = new b2Vec2(_ptr + 104);public var m_u:b2Vec2; // m_u = new b2Vec2(_ptr + 112);public function get m_frequencyHz():Number { return mem._mrf(_ptr + 120); }public function set m_frequencyHz(v:Number):void { mem._mwf(_ptr + 120, v); }public function get m_dampingRatio():Number { return mem._mrf(_ptr + 124); }public function set m_dampingRatio(v:Number):void { mem._mwf(_ptr + 124, v); }public function get m_gamma():Number { return mem._mrf(_ptr + 128); }public function set m_gamma(v:Number):void { mem._mwf(_ptr + 128, v); }public function get m_bias():Number { return mem._mrf(_ptr + 132); }public function set m_bias(v:Number):void { mem._mwf(_ptr + 132, v); }public function get m_impulse():Number { return mem._mrf(_ptr + 136); }public function set m_impulse(v:Number):void { mem._mwf(_ptr + 136, v); }public function get m_mass():Number { return mem._mrf(_ptr + 140); }public function set m_mass(v:Number):void { mem._mwf(_ptr + 140, v); }public function get m_length():Number { return mem._mrf(_ptr + 144); }public function set m_length(v:Number):void { mem._mwf(_ptr + 144, v); }----------b2GearJointDefpublic var _joint1:b2Joint;public function get joint1():b2Joint { return _joint1; }public function set joint1(v:b2Joint):void { mem._mw32(_ptr + 20, v._ptr); _joint1 = v; }public var _joint2:b2Joint;public function get joint2():b2Joint { return _joint2; }public function set joint2(v:b2Joint):void { mem._mw32(_ptr + 24, v._ptr); _joint2 = v; }public function get ratio():Number { return mem._mrf(_ptr + 28); }public function set ratio(v:Number):void { mem._mwf(_ptr + 28, v); }----------b2GearJointpublic var _m_ground1:b2Body;public function get m_ground1():b2Body { return _m_ground1; }public function set m_ground1(v:b2Body):void { mem._mw32(_ptr + 96, v._ptr); _m_ground1 = v; }public var _m_ground2:b2Body;public function get m_ground2():b2Body { return _m_ground2; }public function set m_ground2(v:b2Body):void { mem._mw32(_ptr + 100, v._ptr); _m_ground2 = v; }public var _m_revolute1:b2RevoluteJoint;public function get m_revolute1():b2RevoluteJoint { return _m_revolute1; }public function set m_revolute1(v:b2RevoluteJoint):void { mem._mw32(_ptr + 104, v._ptr); _m_revolute1 = v; }public var _m_prismatic1:b2PrismaticJoint;public function get m_prismatic1():b2PrismaticJoint { return _m_prismatic1; }public function set m_prismatic1(v:b2PrismaticJoint):void { mem._mw32(_ptr + 108, v._ptr); _m_prismatic1 = v; }public var _m_revolute2:b2RevoluteJoint;public function get m_revolute2():b2RevoluteJoint { return _m_revolute2; }public function set m_revolute2(v:b2RevoluteJoint):void { mem._mw32(_ptr + 112, v._ptr); _m_revolute2 = v; }public var _m_prismatic2:b2PrismaticJoint;public function get m_prismatic2():b2PrismaticJoint { return _m_prismatic2; }public function set m_prismatic2(v:b2PrismaticJoint):void { mem._mw32(_ptr + 116, v._ptr); _m_prismatic2 = v; }public var m_groundAnchor1:b2Vec2; // m_groundAnchor1 = new b2Vec2(_ptr + 120);public var m_groundAnchor2:b2Vec2; // m_groundAnchor2 = new b2Vec2(_ptr + 128);public var m_localAnchor1:b2Vec2; // m_localAnchor1 = new b2Vec2(_ptr + 136);public var m_localAnchor2:b2Vec2; // m_localAnchor2 = new b2Vec2(_ptr + 144);public function get m_constant():Number { return mem._mrf(_ptr + 176); }public function set m_constant(v:Number):void { mem._mwf(_ptr + 176, v); }public function get m_ratio():Number { return mem._mrf(_ptr + 180); }public function set m_ratio(v:Number):void { mem._mwf(_ptr + 180, v); }public function get m_mass():Number { return mem._mrf(_ptr + 184); }public function set m_mass(v:Number):void { mem._mwf(_ptr + 184, v); }public function get m_impulse():Number { return mem._mrf(_ptr + 188); }public function set m_impulse(v:Number):void { mem._mwf(_ptr + 188, v); }public var m_J:b2Jacobian; // m_J = new b2Jacobian(_ptr + 152);----------b2LineJointDefpublic var localAnchorA:b2Vec2; // localAnchorA = new b2Vec2(_ptr + 20);public var localAnchorB:b2Vec2; // localAnchorB = new b2Vec2(_ptr + 28);public var localAxisA:b2Vec2; // localAxisA = new b2Vec2(_ptr + 36);public function get enableMotor():Boolean { return mem._mru8(_ptr + 44) == 1; }public function set enableMotor(v:Boolean):void { mem._mw8(_ptr + 44, v ? 1 : 0); }public function get maxMotorTorque():Number { return mem._mrf(_ptr + 48); }public function set maxMotorTorque(v:Number):void { mem._mwf(_ptr + 48, v); }public function get motorSpeed():Number { return mem._mrf(_ptr + 52); }public function set motorSpeed(v:Number):void { mem._mwf(_ptr + 52, v); }public function get frequencyHz():Number { return mem._mrf(_ptr + 56); }public function set frequencyHz(v:Number):void { mem._mwf(_ptr + 56, v); }public function get dampingRatio():Number { return mem._mrf(_ptr + 60); }public function set dampingRatio(v:Number):void { mem._mwf(_ptr + 60, v); }----------b2LineJointpublic var m_localAnchorA:b2Vec2; // m_localAnchorA = new b2Vec2(_ptr + 96);public var m_localAnchorB:b2Vec2; // m_localAnchorB = new b2Vec2(_ptr + 104);public var m_localXAxisA:b2Vec2; // m_localXAxisA = new b2Vec2(_ptr + 112);public var m_localYAxisA:b2Vec2; // m_localYAxisA = new b2Vec2(_ptr + 120);public var m_ax:b2Vec2; // m_ax = new b2Vec2(_ptr + 128);public var m_ay:b2Vec2; // m_ay = new b2Vec2(_ptr + 136);public function get m_sAx():Number { return mem._mrf(_ptr + 144); }public function set m_sAx(v:Number):void { mem._mwf(_ptr + 144, v); }public function get m_sBx():Number { return mem._mrf(_ptr + 148); }public function set m_sBx(v:Number):void { mem._mwf(_ptr + 148, v); }public function get m_sAy():Number { return mem._mrf(_ptr + 152); }public function set m_sAy(v:Number):void { mem._mwf(_ptr + 152, v); }public function get m_sBy():Number { return mem._mrf(_ptr + 156); }public function set m_sBy(v:Number):void { mem._mwf(_ptr + 156, v); }public function get m_mass():Number { return mem._mrf(_ptr + 160); }public function set m_mass(v:Number):void { mem._mwf(_ptr + 160, v); }public function get m_impulse():Number { return mem._mrf(_ptr + 164); }public function set m_impulse(v:Number):void { mem._mwf(_ptr + 164, v); }public function get m_motorMass():Number { return mem._mrf(_ptr + 168); }public function set m_motorMass(v:Number):void { mem._mwf(_ptr + 168, v); }public function get m_motorImpulse():Number { return mem._mrf(_ptr + 172); }public function set m_motorImpulse(v:Number):void { mem._mwf(_ptr + 172, v); }public function get m_springMass():Number { return mem._mrf(_ptr + 176); }public function set m_springMass(v:Number):void { mem._mwf(_ptr + 176, v); }public function get m_springImpulse():Number { return mem._mrf(_ptr + 180); }public function set m_springImpulse(v:Number):void { mem._mwf(_ptr + 180, v); }public function get m_maxMotorTorque():Number { return mem._mrf(_ptr + 184); }public function set m_maxMotorTorque(v:Number):void { mem._mwf(_ptr + 184, v); }public function get m_motorSpeed():Number { return mem._mrf(_ptr + 188); }public function set m_motorSpeed(v:Number):void { mem._mwf(_ptr + 188, v); }public function get m_frequencyHz():Number { return mem._mrf(_ptr + 192); }public function set m_frequencyHz(v:Number):void { mem._mwf(_ptr + 192, v); }public function get m_dampingRatio():Number { return mem._mrf(_ptr + 196); }public function set m_dampingRatio(v:Number):void { mem._mwf(_ptr + 196, v); }public function get m_bias():Number { return mem._mrf(_ptr + 200); }public function set m_bias(v:Number):void { mem._mwf(_ptr + 200, v); }public function get m_gamma():Number { return mem._mrf(_ptr + 204); }public function set m_gamma(v:Number):void { mem._mwf(_ptr + 204, v); }public function get m_enableMotor():Boolean { return mem._mru8(_ptr + 208) == 1; }public function set m_enableMotor(v:Boolean):void { mem._mw8(_ptr + 208, v ? 1 : 0); }----------b2MouseJointDefpublic var target:b2Vec2; // target = new b2Vec2(_ptr + 20);public function get maxForce():Number { return mem._mrf(_ptr + 28); }public function set maxForce(v:Number):void { mem._mwf(_ptr + 28, v); }public function get frequencyHz():Number { return mem._mrf(_ptr + 32); }public function set frequencyHz(v:Number):void { mem._mwf(_ptr + 32, v); }public function get dampingRatio():Number { return mem._mrf(_ptr + 36); }public function set dampingRatio(v:Number):void { mem._mwf(_ptr + 36, v); }----------b2MouseJointpublic var m_localAnchor:b2Vec2; // m_localAnchor = new b2Vec2(_ptr + 96);public var m_target:b2Vec2; // m_target = new b2Vec2(_ptr + 104);public var m_impulse:b2Vec2; // m_impulse = new b2Vec2(_ptr + 112);public var m_C:b2Vec2; // m_C = new b2Vec2(_ptr + 136);public function get m_maxForce():Number { return mem._mrf(_ptr + 144); }public function set m_maxForce(v:Number):void { mem._mwf(_ptr + 144, v); }public function get m_frequencyHz():Number { return mem._mrf(_ptr + 148); }public function set m_frequencyHz(v:Number):void { mem._mwf(_ptr + 148, v); }public function get m_dampingRatio():Number { return mem._mrf(_ptr + 152); }public function set m_dampingRatio(v:Number):void { mem._mwf(_ptr + 152, v); }public function get m_beta():Number { return mem._mrf(_ptr + 156); }public function set m_beta(v:Number):void { mem._mwf(_ptr + 156, v); }public function get m_gamma():Number { return mem._mrf(_ptr + 160); }public function set m_gamma(v:Number):void { mem._mwf(_ptr + 160, v); }----------b2PrismaticJointDefpublic var localAnchorA:b2Vec2; // localAnchorA = new b2Vec2(_ptr + 20);public var localAnchorB:b2Vec2; // localAnchorB = new b2Vec2(_ptr + 28);public var localAxis1:b2Vec2; // localAxis1 = new b2Vec2(_ptr + 36);public function get referenceAngle():Number { return mem._mrf(_ptr + 44); }public function set referenceAngle(v:Number):void { mem._mwf(_ptr + 44, v); }public function get enableLimit():Boolean { return mem._mru8(_ptr + 48) == 1; }public function set enableLimit(v:Boolean):void { mem._mw8(_ptr + 48, v ? 1 : 0); }public function get lowerTranslation():Number { return mem._mrf(_ptr + 52); }public function set lowerTranslation(v:Number):void { mem._mwf(_ptr + 52, v); }public function get upperTranslation():Number { return mem._mrf(_ptr + 56); }public function set upperTranslation(v:Number):void { mem._mwf(_ptr + 56, v); }public function get enableMotor():Boolean { return mem._mru8(_ptr + 60) == 1; }public function set enableMotor(v:Boolean):void { mem._mw8(_ptr + 60, v ? 1 : 0); }public function get maxMotorForce():Number { return mem._mrf(_ptr + 64); }public function set maxMotorForce(v:Number):void { mem._mwf(_ptr + 64, v); }public function get motorSpeed():Number { return mem._mrf(_ptr + 68); }public function set motorSpeed(v:Number):void { mem._mwf(_ptr + 68, v); }----------b2PrismaticJointpublic var m_localAnchor1:b2Vec2; // m_localAnchor1 = new b2Vec2(_ptr + 96);public var m_localAnchor2:b2Vec2; // m_localAnchor2 = new b2Vec2(_ptr + 104);public var m_localXAxis1:b2Vec2; // m_localXAxis1 = new b2Vec2(_ptr + 112);public var m_localYAxis1:b2Vec2; // m_localYAxis1 = new b2Vec2(_ptr + 120);public function get m_refAngle():Number { return mem._mrf(_ptr + 128); }public function set m_refAngle(v:Number):void { mem._mwf(_ptr + 128, v); }public var m_axis:b2Vec2; // m_axis = new b2Vec2(_ptr + 132);public var m_perp:b2Vec2; // m_perp = new b2Vec2(_ptr + 140);public function get m_s1():Number { return mem._mrf(_ptr + 148); }public function set m_s1(v:Number):void { mem._mwf(_ptr + 148, v); }public function get m_s2():Number { return mem._mrf(_ptr + 152); }public function set m_s2(v:Number):void { mem._mwf(_ptr + 152, v); }public function get m_a1():Number { return mem._mrf(_ptr + 156); }public function set m_a1(v:Number):void { mem._mwf(_ptr + 156, v); }public function get m_a2():Number { return mem._mrf(_ptr + 160); }public function set m_a2(v:Number):void { mem._mwf(_ptr + 160, v); }public var m_impulse:b2Vec3; // m_impulse = new b2Vec3(_ptr + 200);public function get m_motorMass():Number { return mem._mrf(_ptr + 212); }public function set m_motorMass(v:Number):void { mem._mwf(_ptr + 212, v); }public function get m_motorImpulse():Number { return mem._mrf(_ptr + 216); }public function set m_motorImpulse(v:Number):void { mem._mwf(_ptr + 216, v); }public function get m_lowerTranslation():Number { return mem._mrf(_ptr + 220); }public function set m_lowerTranslation(v:Number):void { mem._mwf(_ptr + 220, v); }public function get m_upperTranslation():Number { return mem._mrf(_ptr + 224); }public function set m_upperTranslation(v:Number):void { mem._mwf(_ptr + 224, v); }public function get m_maxMotorForce():Number { return mem._mrf(_ptr + 228); }public function set m_maxMotorForce(v:Number):void { mem._mwf(_ptr + 228, v); }public function get m_motorSpeed():Number { return mem._mrf(_ptr + 232); }public function set m_motorSpeed(v:Number):void { mem._mwf(_ptr + 232, v); }public function get m_enableLimit():Boolean { return mem._mru8(_ptr + 236) == 1; }public function set m_enableLimit(v:Boolean):void { mem._mw8(_ptr + 236, v ? 1 : 0); }public function get m_enableMotor():Boolean { return mem._mru8(_ptr + 237) == 1; }public function set m_enableMotor(v:Boolean):void { mem._mw8(_ptr + 237, v ? 1 : 0); }public function get m_limitState():int { return mem._mrs16(_ptr + 240); }public function set m_limitState(v:int):void { mem._mw16(_ptr + 240, v); }----------b2PulleyJointDefpublic var groundAnchorA:b2Vec2; // groundAnchorA = new b2Vec2(_ptr + 20);public var groundAnchorB:b2Vec2; // groundAnchorB = new b2Vec2(_ptr + 28);public var localAnchorA:b2Vec2; // localAnchorA = new b2Vec2(_ptr + 36);public var localAnchorB:b2Vec2; // localAnchorB = new b2Vec2(_ptr + 44);public function get lengthA():Number { return mem._mrf(_ptr + 52); }public function set lengthA(v:Number):void { mem._mwf(_ptr + 52, v); }public function get maxLengthA():Number { return mem._mrf(_ptr + 56); }public function set maxLengthA(v:Number):void { mem._mwf(_ptr + 56, v); }public function get lengthB():Number { return mem._mrf(_ptr + 60); }public function set lengthB(v:Number):void { mem._mwf(_ptr + 60, v); }public function get maxLengthB():Number { return mem._mrf(_ptr + 64); }public function set maxLengthB(v:Number):void { mem._mwf(_ptr + 64, v); }public function get ratio():Number { return mem._mrf(_ptr + 68); }public function set ratio(v:Number):void { mem._mwf(_ptr + 68, v); }----------b2PulleyJointpublic var m_groundAnchor1:b2Vec2; // m_groundAnchor1 = new b2Vec2(_ptr + 96);public var m_groundAnchor2:b2Vec2; // m_groundAnchor2 = new b2Vec2(_ptr + 104);public var m_localAnchor1:b2Vec2; // m_localAnchor1 = new b2Vec2(_ptr + 112);public var m_localAnchor2:b2Vec2; // m_localAnchor2 = new b2Vec2(_ptr + 120);public var m_u1:b2Vec2; // m_u1 = new b2Vec2(_ptr + 128);public var m_u2:b2Vec2; // m_u2 = new b2Vec2(_ptr + 136);public function get m_constant():Number { return mem._mrf(_ptr + 144); }public function set m_constant(v:Number):void { mem._mwf(_ptr + 144, v); }public function get m_ratio():Number { return mem._mrf(_ptr + 148); }public function set m_ratio(v:Number):void { mem._mwf(_ptr + 148, v); }public function get m_maxLength1():Number { return mem._mrf(_ptr + 152); }public function set m_maxLength1(v:Number):void { mem._mwf(_ptr + 152, v); }public function get m_maxLength2():Number { return mem._mrf(_ptr + 156); }public function set m_maxLength2(v:Number):void { mem._mwf(_ptr + 156, v); }public function get m_pulleyMass():Number { return mem._mrf(_ptr + 160); }public function set m_pulleyMass(v:Number):void { mem._mwf(_ptr + 160, v); }public function get m_limitMass1():Number { return mem._mrf(_ptr + 164); }public function set m_limitMass1(v:Number):void { mem._mwf(_ptr + 164, v); }public function get m_limitMass2():Number { return mem._mrf(_ptr + 168); }public function set m_limitMass2(v:Number):void { mem._mwf(_ptr + 168, v); }public function get m_impulse():Number { return mem._mrf(_ptr + 172); }public function set m_impulse(v:Number):void { mem._mwf(_ptr + 172, v); }public function get m_limitImpulse1():Number { return mem._mrf(_ptr + 176); }public function set m_limitImpulse1(v:Number):void { mem._mwf(_ptr + 176, v); }public function get m_limitImpulse2():Number { return mem._mrf(_ptr + 180); }public function set m_limitImpulse2(v:Number):void { mem._mwf(_ptr + 180, v); }public function get m_state():int { return mem._mrs16(_ptr + 184); }public function set m_state(v:int):void { mem._mw16(_ptr + 184, v); }public function get m_limitState1():int { return mem._mrs16(_ptr + 188); }public function set m_limitState1(v:int):void { mem._mw16(_ptr + 188, v); }public function get m_limitState2():int { return mem._mrs16(_ptr + 192); }public function set m_limitState2(v:int):void { mem._mw16(_ptr + 192, v); }----------b2RevoluteJointDefpublic var localAnchorA:b2Vec2; // localAnchorA = new b2Vec2(_ptr + 20);public var localAnchorB:b2Vec2; // localAnchorB = new b2Vec2(_ptr + 28);public function get referenceAngle():Number { return mem._mrf(_ptr + 36); }public function set referenceAngle(v:Number):void { mem._mwf(_ptr + 36, v); }public function get enableLimit():Boolean { return mem._mru8(_ptr + 40) == 1; }public function set enableLimit(v:Boolean):void { mem._mw8(_ptr + 40, v ? 1 : 0); }public function get lowerAngle():Number { return mem._mrf(_ptr + 44); }public function set lowerAngle(v:Number):void { mem._mwf(_ptr + 44, v); }public function get upperAngle():Number { return mem._mrf(_ptr + 48); }public function set upperAngle(v:Number):void { mem._mwf(_ptr + 48, v); }public function get enableMotor():Boolean { return mem._mru8(_ptr + 52) == 1; }public function set enableMotor(v:Boolean):void { mem._mw8(_ptr + 52, v ? 1 : 0); }public function get motorSpeed():Number { return mem._mrf(_ptr + 56); }public function set motorSpeed(v:Number):void { mem._mwf(_ptr + 56, v); }public function get maxMotorTorque():Number { return mem._mrf(_ptr + 60); }public function set maxMotorTorque(v:Number):void { mem._mwf(_ptr + 60, v); }----------b2RevoluteJointpublic var m_localAnchor1:b2Vec2; // m_localAnchor1 = new b2Vec2(_ptr + 96);public var m_localAnchor2:b2Vec2; // m_localAnchor2 = new b2Vec2(_ptr + 104);public var m_impulse:b2Vec3; // m_impulse = new b2Vec3(_ptr + 112);public function get m_motorImpulse():Number { return mem._mrf(_ptr + 124); }public function set m_motorImpulse(v:Number):void { mem._mwf(_ptr + 124, v); }public function get m_motorMass():Number { return mem._mrf(_ptr + 164); }public function set m_motorMass(v:Number):void { mem._mwf(_ptr + 164, v); }public function get m_enableMotor():Boolean { return mem._mru8(_ptr + 168) == 1; }public function set m_enableMotor(v:Boolean):void { mem._mw8(_ptr + 168, v ? 1 : 0); }public function get m_maxMotorTorque():Number { return mem._mrf(_ptr + 172); }public function set m_maxMotorTorque(v:Number):void { mem._mwf(_ptr + 172, v); }public function get m_motorSpeed():Number { return mem._mrf(_ptr + 176); }public function set m_motorSpeed(v:Number):void { mem._mwf(_ptr + 176, v); }public function get m_enableLimit():Boolean { return mem._mru8(_ptr + 180) == 1; }public function set m_enableLimit(v:Boolean):void { mem._mw8(_ptr + 180, v ? 1 : 0); }public function get m_referenceAngle():Number { return mem._mrf(_ptr + 184); }public function set m_referenceAngle(v:Number):void { mem._mwf(_ptr + 184, v); }public function get m_lowerAngle():Number { return mem._mrf(_ptr + 188); }public function set m_lowerAngle(v:Number):void { mem._mwf(_ptr + 188, v); }public function get m_upperAngle():Number { return mem._mrf(_ptr + 192); }public function set m_upperAngle(v:Number):void { mem._mwf(_ptr + 192, v); }public function get m_limitState():int { return mem._mrs16(_ptr + 196); }public function set m_limitState(v:int):void { mem._mw16(_ptr + 196, v); }----------b2WeldJointDefpublic var localAnchorA:b2Vec2; // localAnchorA = new b2Vec2(_ptr + 20);public var localAnchorB:b2Vec2; // localAnchorB = new b2Vec2(_ptr + 28);public function get referenceAngle():Number { return mem._mrf(_ptr + 36); }public function set referenceAngle(v:Number):void { mem._mwf(_ptr + 36, v); }----------b2WeldJointpublic var m_localAnchorA:b2Vec2; // m_localAnchorA = new b2Vec2(_ptr + 96);public var m_localAnchorB:b2Vec2; // m_localAnchorB = new b2Vec2(_ptr + 104);public function get m_referenceAngle():Number { return mem._mrf(_ptr + 112); }public function set m_referenceAngle(v:Number):void { mem._mwf(_ptr + 112, v); }public var m_impulse:b2Vec3; // m_impulse = new b2Vec3(_ptr + 116);public var m_mass:b2Mat33; // m_mass = new b2Mat33(_ptr + 128);----------b2RopeJointDefpublic var localAnchorA:b2Vec2; // localAnchorA = new b2Vec2(_ptr + 20);public var localAnchorB:b2Vec2; // localAnchorB = new b2Vec2(_ptr + 28);public function get maxLength():Number { return mem._mrf(_ptr + 36); }public function set maxLength(v:Number):void { mem._mwf(_ptr + 36, v); }----------b2RopeJointpublic var m_localAnchorA:b2Vec2; // m_localAnchorA = new b2Vec2(_ptr + 96);public var m_localAnchorB:b2Vec2; // m_localAnchorB = new b2Vec2(_ptr + 104);public function get m_maxLength():Number { return mem._mrf(_ptr + 112); }public function set m_maxLength(v:Number):void { mem._mwf(_ptr + 112, v); }public function get m_length():Number { return mem._mrf(_ptr + 116); }public function set m_length(v:Number):void { mem._mwf(_ptr + 116, v); }public var m_u:b2Vec2; // m_u = new b2Vec2(_ptr + 120);public var m_rA:b2Vec2; // m_rA = new b2Vec2(_ptr + 128);public var m_rB:b2Vec2; // m_rB = new b2Vec2(_ptr + 136);public function get m_mass():Number { return mem._mrf(_ptr + 144); }public function set m_mass(v:Number):void { mem._mwf(_ptr + 144, v); }public function get m_impulse():Number { return mem._mrf(_ptr + 148); }public function set m_impulse(v:Number):void { mem._mwf(_ptr + 148, v); }----------b2FrictionJointDefpublic var localAnchorA:b2Vec2; // localAnchorA = new b2Vec2(_ptr + 20);public var localAnchorB:b2Vec2; // localAnchorB = new b2Vec2(_ptr + 28);public function get maxForce():Number { return mem._mrf(_ptr + 36); }public function set maxForce(v:Number):void { mem._mwf(_ptr + 36, v); }public function get maxTorque():Number { return mem._mrf(_ptr + 40); }public function set maxTorque(v:Number):void { mem._mwf(_ptr + 40, v); }----------b2FrictionJointpublic var m_localAnchorA:b2Vec2; // m_localAnchorA = new b2Vec2(_ptr + 96);public var m_localAnchorB:b2Vec2; // m_localAnchorB = new b2Vec2(_ptr + 104);public var m_linearMass:b2Mat22; // m_linearMass = new b2Mat22(_ptr + 112);public function get m_angularMass():Number { return mem._mrf(_ptr + 128); }public function set m_angularMass(v:Number):void { mem._mwf(_ptr + 128, v); }public var m_linearImpulse:b2Vec2; // m_linearImpulse = new b2Vec2(_ptr + 132);public function get m_angularImpulse():Number { return mem._mrf(_ptr + 140); }public function set m_angularImpulse(v:Number):void { mem._mwf(_ptr + 140, v); }public function get m_maxForce():Number { return mem._mrf(_ptr + 144); }public function set m_maxForce(v:Number):void { mem._mwf(_ptr + 144, v); }public function get m_maxTorque():Number { return mem._mrf(_ptr + 148); }public function set m_maxTorque(v:Number):void { mem._mwf(_ptr + 148, v); }----------b2BroadPhasepublic function get m_proxyCount():int { return mem._mr32(_ptr + 28); }public function set m_proxyCount(v:int):void { mem._mw32(_ptr + 28, v); }public function get m_moveBuffer():int { return mem._mr32(_ptr + 32); }public function set m_moveBuffer(v:int):void { mem._mw32(_ptr + 32, v); }public function get m_moveCapacity():int { return mem._mr32(_ptr + 36); }public function set m_moveCapacity(v:int):void { mem._mw32(_ptr + 36, v); }public function get m_moveCount():int { return mem._mr32(_ptr + 40); }public function set m_moveCount(v:int):void { mem._mw32(_ptr + 40, v); }public function get m_pairCapacity():int { return mem._mr32(_ptr + 48); }public function set m_pairCapacity(v:int):void { mem._mw32(_ptr + 48, v); }public function get m_pairCount():int { return mem._mr32(_ptr + 52); }public function set m_pairCount(v:int):void { mem._mw32(_ptr + 52, v); }public function get m_queryProxyId():int { return mem._mr32(_ptr + 56); }public function set m_queryProxyId(v:int):void { mem._mw32(_ptr + 56, v); }----------b2ContactManagerpublic var m_contactList:b2Contact; // m_contactList = new b2Contact(_ptr + 60);public var m_broadPhase:b2BroadPhase; // m_broadPhase = new b2BroadPhase(_ptr + 0);public function get m_contactCount():int { return mem._mr32(_ptr + 64); }public function set m_contactCount(v:int):void { mem._mw32(_ptr + 64, v); }----------b2Jacobianpublic var linearA:b2Vec2; // linearA = new b2Vec2(_ptr + 0);public function get angularA():Number { return mem._mrf(_ptr + 8); }public function set angularA(v:Number):void { mem._mwf(_ptr + 8, v); }public var linearB:b2Vec2; // linearB = new b2Vec2(_ptr + 12);public function get angularB():Number { return mem._mrf(_ptr + 20); }public function set angularB(v:Number):void { mem._mwf(_ptr + 20, v); }----------b2ContactImpulsepublic function get normalImpulses[0]():Number { return mem._mrf(_ptr + 0); }public function set normalImpulses[0](v:Number):void { mem._mwf(_ptr + 0, v); }public function get normalImpulses[1]():Number { return mem._mrf(_ptr + 4); }public function set normalImpulses[1](v:Number):void { mem._mwf(_ptr + 4, v); }public function get tangentImpulses[0]():Number { return mem._mrf(_ptr + 8); }public function set tangentImpulses[0](v:Number):void { mem._mwf(_ptr + 8, v); }public function get tangentImpulses[1]():Number { return mem._mrf(_ptr + 12); }public function set tangentImpulses[1](v:Number):void { mem._mwf(_ptr + 12, v); }----------b2DistanceInputpublic var proxyA:b2DistanceProxy; // proxyA = new b2DistanceProxy(_ptr + 0);public var proxyB:b2DistanceProxy; // proxyB = new b2DistanceProxy(_ptr + 28);public var transformA:b2Transform; // transformA = new b2Transform(_ptr + 56);public var transformB:b2Transform; // transformB = new b2Transform(_ptr + 80);public function get useRadii():Boolean { return mem._mru8(_ptr + 104) == 1; }public function set useRadii(v:Boolean):void { mem._mw8(_ptr + 104, v ? 1 : 0); }----------b2DistanceOutputpublic var pointA:b2Vec2; // pointA = new b2Vec2(_ptr + 0);public var pointB:b2Vec2; // pointB = new b2Vec2(_ptr + 8);public function get distance():Number { return mem._mrf(_ptr + 16); }public function set distance(v:Number):void { mem._mwf(_ptr + 16, v); }public function get iterations():int { return mem._mr32(_ptr + 20); }public function set iterations(v:int):void { mem._mw32(_ptr + 20, v); }----------b2SimplexCachepublic function get metric():Number { return mem._mrf(_ptr + 0); }public function set metric(v:Number):void { mem._mwf(_ptr + 0, v); }public function get count():int { return mem._mru16(_ptr + 4); }public function set count(v:int):void { mem._mw16(_ptr + 4, v); }public function get indexA():int { return mem._mru8(_ptr + 6); }public function set indexA(v:int):void { mem._mw8(_ptr + 6, v); }public function get indexB():int { return mem._mru8(_ptr + 9); }public function set indexB(v:int):void { mem._mw8(_ptr + 9, v); }----------b2DistanceProxypublic function get m_vertices():Vector.<V2> { return readVertices(_ptr + 16, m_count); }public function set m_vertices(v:Vector.<V2>):void { writeVertices(_ptr + 16, v); m_count = v.length; }public function get m_count():int { return mem._mr32(_ptr + 20); }public function set m_count(v:int):void { mem._mw32(_ptr + 20, v); }public function get m_radius():Number { return mem._mrf(_ptr + 24); }public function set m_radius(v:Number):void { mem._mwf(_ptr + 24, v); }----------b2EdgeShapepublic var m_vertex0:b2Vec2; // m_vertex0 = new b2Vec2(_ptr + 32);public var m_vertex1:b2Vec2; // m_vertex1 = new b2Vec2(_ptr + 16);public var m_vertex2:b2Vec2; // m_vertex2 = new b2Vec2(_ptr + 24);public var m_vertex3:b2Vec2; // m_vertex3 = new b2Vec2(_ptr + 40);public function get m_hasVertex0():Boolean { return mem._mru8(_ptr + 48) == 1; }public function set m_hasVertex0(v:Boolean):void { mem._mw8(_ptr + 48, v ? 1 : 0); }public function get m_hasVertex3():Boolean { return mem._mru8(_ptr + 49) == 1; }public function set m_hasVertex3(v:Boolean):void { mem._mw8(_ptr + 49, v ? 1 : 0); }----------b2LoopShapepublic function get m_vertices():Vector.<V2> { return readVertices(_ptr + 16, m_count); }public function set m_vertices(v:Vector.<V2>):void { writeVertices(_ptr + 16, v); m_count = v.length; }public function get m_count():int { return mem._mr32(_ptr + 20); }public function set m_count(v:int):void { mem._mw32(_ptr + 20, v); }Creating and stepping a b2World in C++C++ b2World test done!10797161079712107970810797041079700107969610796921079688107968410796801079676107967210796681079664107966010796561079652107964831 milliseconds to call an empty C++ function 1000 times1 milliseconds to call an empty AS3 function 1000 times[object Object]75 milliseconds to get / set a V2 1000000 times1066 milliseconds to get / set a b2Vec2 1000000 times96 milliseconds to call ApplyForce() in AS3 10000 times769 milliseconds to call ApplyForce() in C++ 10000 times11 milliseconds to directly set m_force 10000 times21Debug session terminated.